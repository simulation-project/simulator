<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>Module /home/marwa/trunk_after_call/ms/test/ms_app_SUITE.erl</title>
<meta http-equiv="cache-control" content="no-cache">
<link rel="stylesheet" href="../../ct_default.css" type="text/css"></head>
<body>

<pre>
    1:<i>%%% Copyright (C) 2012 ITI Egypt.</i>
    2:<i>%%%</i>
    3:<i>%%% The contents of this file are subject to the Erlang Public License,</i>
    4:<i>%%% Version 1.1, (the "License"); you may not use this file except in</i>
    5:<i>%%% compliance with the License. You should have received a copy of the</i>
    6:<i>%%% Erlang Public License along with this software. If not, it can be</i>
    7:<i>%%% retrieved via the world wide web at http://www.erlang.org/.</i>
    8:<i>%%%</i>
    9:<i>%%% Software distributed under the License is distributed on an "AS IS"</i>
<a name="10"></a>   10:<i>%%% basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See</i>
   11:<i>%%% the License for the specific language governing rights and limitations</i>
   12:<i>%%% under the License.</i>
   13:<i>%%%</i>
   14:<i>%%% The Initial Developer of the Original Code is Ericsson Utvecklings AB.</i>
   15:<i>%%% Portions created by Ericsson are Copyright 1999, Ericsson Utvecklings</i>
   16:<i>%%% AB. All Rights Reserved.</i>
   17:
   18:<i>%%% @doc</i>
   19:<i>%%%</i>
<a name="20"></a>   20:<i>%%% @copyright 2012 ITI Egypt.</i>
   21:<i>%%% @author Marwa El-Shahed &lt;marwa.elshahed@hotmail.com&gt;</i>
   22:<i>%%%         [http://www.iti.gov.eg/]</i>
   23:<i>%%% @end</i>
   24:-<b>module</b>(ms_app_SUITE).
   25:
   26:<i>%%% Include files</i>
   27:<i>%-include("/usr/lib/erlang/lib/common_test-1.5.5/include/ct.hrl").</i>
   28:<i>%-include("ct.hrl").</i>
   29:
<a name="30"></a>   30:<i>%%% External exports</i>
   31:-<b>compile</b>(export_all).
   32:
   33:<i>%%% Macros</i>
   34:-<b>define</b>(MATCH_SPEC, [{'_', [], [{message, {return_trace}}]}]).
   35:-<b>define</b>(MAX_TIME, 10000).
   36:-<b>define</b>(STUBS_DIR, "../../stubs").  % Tests run in log/ct_run.*
   37:
   38:
   39:<i>%%%-----------------------------------------------------------------------------</i>
<a name="40"></a>   40:<i>%%% Suite Exports</i>
   41:<i>%%%-----------------------------------------------------------------------------</i>
   42:<i>%% @spec all() -&gt; Result</i>
   43:<i>%%    Result = TestCases | {skip, Reason}</i>
   44:<i>%%    TestCases = [TestCase]</i>
   45:<i>%%    TestCase = atom()</i>
   46:<i>%%    Reason   = term()</i>
   47:<i>%%</i>
   48:<i>%% @doc Returns the list of test cases that are to be executed.</i>
   49:<i>%% @end</i>
<a name=all><a name="50"></a>   50:<b>all</b></a>() -&gt;
   51:    [normal_case].
   52:
   53:<i>%% @spec sequences() -&gt; Sequences</i>
   54:<i>%%    Sequences = [{Name, Cases}]</i>
   55:<i>%%    Name = atom()</i>
   56:<i>%%    Cases = [Case]</i>
   57:<i>%%    Case = atom()</i>
   58:<i>%%</i>
   59:<i>%% @doc Specifies test case sequences.</i>
<a name="60"></a>   60:<i>%% @end</i>
<a name=sequences>   61:<b>sequences</b></a>() -&gt;
   62:    [].
   63:
   64:<i>%% @spec suite() -&gt; Info</i>
   65:<i>%%    Info = [tuple()]</i>
   66:<i>%%</i>
   67:<i>%% @doc Returns a list of tuples to set default properties for the suite.</i>
   68:<i>%% @end</i>
<a name=suite>   69:<b>suite</b></a>() -&gt;
<a name="70"></a>   70:    [{timetrap, {minutes, 60}},
   71:     {required, conf_file}].
   72:
   73:<i>%%%-----------------------------------------------------------------------------</i>
   74:<i>%%% Init Suite Exports</i>
   75:<i>%%%-----------------------------------------------------------------------------</i>
   76:<i>%% @spec init_per_suite(Conf) -&gt; Conf</i>
   77:<i>%%     Conf = [tuple()]</i>
   78:<i>%%</i>
   79:<i>%% @doc Initiation before the whole suite.</i>
<a name="80"></a>   80:<i>%%</i>
   81:<i>%% &lt;b&gt;Note:&lt;/b&gt; This function is free to add any key/value pairs to the</i>
   82:<i>%% &lt;u&gt;Conf&lt;/u&gt; variable, but should NOT alter/remove any existing entries.</i>
   83:<i>%% @end</i>
<a name=init_per_suite>   84:<b>init_per_suite</b></a>(Conf) -&gt;
   85:    ok = application:start(sasl),
   86:    ok = application:start(ms),
   87:    ok = application:start(msc),
   88:    ok = application:start(hlr),
   89:    lists:foreach(fun(X) -&gt; code:add_path(X) end, ct:get_config(paths, [])),
<a name="90"></a>   90:    {A1, A2, A3} = now(),
   91:    random:seed(A1, A2, A3),
   92:    dbg:tracer(),
   93:    dbg:p(all, [c, sos, sol]),
   94:    %MaxTime = ct:get_config(max_time, ?MAX_TIME),
   95:    %AdpConf = xml_schema:parse(ct:get_config(conf_file)),
   96:    %[{max_time, MaxTime} | Conf].
   97:    %[{conf, AdpConf} | Conf].
   98:    Conf.
   99:
<a name="100"></a>  100:<i>%%%-----------------------------------------------------------------------------</i>
  101:<i>%%% End Suite Exports</i>
  102:<i>%%%-----------------------------------------------------------------------------</i>
  103:<i>%% @spec end_per_suite(Conf) -&gt; Result</i>
  104:<i>%%    Conf = [tuple()]</i>
  105:<i>%%    Result = ok | {save_config, Conf1}</i>
  106:<i>%%</i>
  107:<i>%% @doc Cleanup after the suite.</i>
  108:<i>%% @end</i>
<a name=end_per_suite>  109:<b>end_per_suite</b></a>(_Conf) -&gt;
<a name="110"></a>  110:    ok = application:stop(hlr),
  111:    ok = application:stop(msc),
  112:    ok = application:stop(ms),
  113:    ok = application:stop(sasl).
  114:
  115:<i>%%%-----------------------------------------------------------------------------</i>
  116:<i>%%% Init Case Exports</i>
  117:<i>%%%-----------------------------------------------------------------------------</i>
  118:<i>%% @spec init_per_testcase(Case, Conf) -&gt; Result</i>
  119:<i>%%    Case = atom()</i>
<a name="120"></a>  120:<i>%%    Conf = [tuple()]</i>
  121:<i>%%    Result = NewConf |</i>
  122:<i>%%             {skip, Reason} |</i>
  123:<i>%%             {skip_and_save, Reason, NewConf}</i>
  124:<i>%%    NewConf = [tuple()]</i>
  125:<i>%%    Reason = term()</i>
  126:<i>%%</i>
  127:<i>%% @doc Initialization before each test case.</i>
  128:<i>%% @end</i>
<a name=init_per_testcase>  129:<b>init_per_testcase</b></a>(Case, Conf) -&gt;
<a name="130"></a>  130:    ct:print("Starting test case ~p", [Case]),
  131:    init_stubs(Case),
  132:    init_traces(Case),
  133:    Conf.
  134:
<a name=init_stubs>  135:<b>init_stubs</b></a>(Case) -&gt;
  136:    NegCases = ct:get_config(neg_cases, []),
  137:    Stubs = proplists:get_value(Case, NegCases, []),
  138:    lists:foreach(fun(Stub) -&gt; load_stub(Stub, true) end, Stubs).
  139:
<a name=init_traces><a name="140"></a>  140:<b>init_traces</b></a>(Case) -&gt;
  141:    TpCases = ct:get_config(tp_cases, []),
  142:    Tps = proplists:get_value(Case, TpCases, []),
  143:    lists:foreach(fun(Tp) -&gt; add_trace(tp, Tp) end, Tps),
  144:    TplCases = ct:get_config(tpl_cases, []),
  145:    Tpls = proplists:get_value(Case, TplCases, []),
  146:    lists:foreach(fun(Tpl) -&gt; add_trace(tp, Tpl) end, Tpls).
  147:
  148:<i>%%%-----------------------------------------------------------------------------</i>
  149:<i>%%% End Case Exports</i>
<a name="150"></a>  150:<i>%%%-----------------------------------------------------------------------------</i>
<a name=end_per_testcase>  151:<b>end_per_testcase</b></a>(Case, Conf) -&gt;
  152:    end_traces(Case),
  153:    end_stubs(Case),
  154:    ct:print("Test case ~p completed", [Case]),
  155:    Conf.
  156:
<a name=end_stubs>  157:<b>end_stubs</b></a>(Case) -&gt;
  158:    NegCases = ct:get_config(neg_cases, []),
  159:    Stubs = proplists:get_value(Case, NegCases, []),
<a name="160"></a>  160:    lists:foreach(fun purge_stub/1, Stubs).
  161:
<a name=end_traces>  162:<b>end_traces</b></a>(Case) -&gt;
  163:    TpCases = ct:get_config(tp_cases, []),
  164:    Tps = proplists:get_value(Case, TpCases, []),
  165:    lists:foreach(fun(Tp) -&gt; del_trace(ctp, Tp) end, Tps),
  166:    TplCases = ct:get_config(tpl_cases, []),
  167:    Tpls = proplists:get_value(Case, TplCases, []),
  168:    lists:foreach(fun(Tpl) -&gt; del_trace(ctpl, Tpl) end, Tpls).
  169:
<a name="170"></a>  170:<i>%%%-----------------------------------------------------------------------------</i>
  171:<i>%%% Test Cases</i>
  172:<i>%%%-----------------------------------------------------------------------------</i>
<a name=normal_case>  173:<b>normal_case</b></a>()-&gt;
  174:    [{userdata, [{doc, "Tests the public API."}]}].
  175:
<a name=normal_case>  176:<b>normal_case</b></a>(_Conf)-&gt;
  177:   code:add_path("../test/stubs"),
  178:   {ok,_PID1} = ms_app:create_ms({ms1,lai1}),
  179:   {ok,_PID2} = ms_app:create_ms({ms2,lai2}),
<a name="180"></a>  180:    ok = ms_app:change_state({ms1,turn_on_idle}),
  181:    ok = ms_app:get_state(ms1),
  182:    ok = ms_app:change_state({ms2,turn_on_idle}),
  183:    ok = ms_app:get_state(ms1),
  184:    ok = ms_app:change_lai({ms1,lai2}),
  185:    ok = ms_app:change_lai({ms2,lai1}),
  186:    ok = ms_app:call_setup({ms1,lai2,bno2}),
  187:    ok = ms_app:connect_msg(ms2,lai1),
  188:    ok = ms_app:get_state(ms1),
  189:    ok = ms_app:get_state(ms1),
<a name="190"></a>  190:    ok = ms_app:change_state({ms1,turn_off}),
  191:    ok = ms_app:get_state(ms1),
  192:    ok = ms_app:change_state({ms2,turn_off}),
  193:    ok = ms_app:get_state(ms1).
  194:    
  195:<i>%%%-----------------------------------------------------------------------------</i>
  196:<i>%%% Tracing Util Functions</i>
  197:<i>%%%-----------------------------------------------------------------------------</i>
<a name=add_trace>  198:<b>add_trace</b></a>(TpFun, {Mod, Fun, Spec}) -&gt;
  199:    dbg:TpFun(Mod, Fun, Spec);
<a name=add_trace><a name="200"></a>  200:<b>add_trace</b></a>(TpFun, {Mod, Fun}) -&gt;
  201:    dbg:TpFun(Mod, Fun, ?MATCH_SPEC);
<a name=add_trace>  202:<b>add_trace</b></a>(TpFun, Mod) -&gt;
  203:    dbg:TpFun(Mod, ?MATCH_SPEC).
  204:
  205:
<a name=del_trace>  206:<b>del_trace</b></a>(CtpFun, {Mod, Fun, _Spec}) -&gt;
  207:    dbg:CtpFun(Mod, Fun);
<a name=del_trace>  208:<b>del_trace</b></a>(CtpFun, {Mod, Fun}) -&gt;
  209:    dbg:CtpFun(Mod, Fun);
<a name=del_trace><a name="210"></a>  210:<b>del_trace</b></a>(CtpFun, Mod) -&gt;
  211:    dbg:CtpFun(Mod).
  212:
  213:<i>%%%-----------------------------------------------------------------------------</i>
  214:<i>%%% Stub Util Functions</i>
  215:<i>%%%-----------------------------------------------------------------------------</i>
<a name=load_stub>  216:<b>load_stub</b></a>(Stub, NegTest) -&gt;
  217:    Opts = if NegTest -&gt; [binary, {d, neg_case}]; true -&gt;  [binary] end,
  218:    Erl = atom_to_list(Stub) ++ ".erl",
  219:    ct:print("Compiling ~s with options ~p", [Erl, Opts]),
<a name="220"></a>  220:    {ok, Mod, Bin} = compile:file(filename:join(?STUBS_DIR, Erl), Opts),
  221:    ct:print("Purge default ~p stub", [Mod]),
  222:    code:purge(Mod),
  223:    code:delete(Mod),
  224:    ct:print("Loading new ~p stub", [Mod]),
  225:    Beam = atom_to_list(Mod) ++ code:objfile_extension(),
  226:    {module, Mod} = code:load_binary(Mod, Beam, Bin).
  227:
  228:
<a name=purge_stub>  229:<b>purge_stub</b></a>(Stub) -&gt;
<a name="230"></a>  230:    ct:print("Purge ~p stub", [Stub]),
  231:    code:purge(Stub),
  232:    code:delete(Stub),
  233:    ct:print("Reloading default ~p stub", [Stub]),
  234:    {module, Stub} = code:load_file(Stub).
</pre>
</body>
</html>
